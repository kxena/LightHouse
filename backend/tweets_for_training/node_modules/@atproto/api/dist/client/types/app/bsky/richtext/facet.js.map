{"version":3,"file":"facet.js","sourceRoot":"","sources":["../../../../../../src/client/types/app/bsky/richtext/facet.ts"],"names":[],"mappings":";;AAyBA,wBAEC;AAED,oCAEC;AAUD,8BAEC;AAED,0CAEC;AAUD,wBAEC;AAED,oCAEC;AAUD,sBAEC;AAED,kCAEC;AAWD,kCAEC;AAED,8CAEC;AA3FD,mDAA4D;AAC5D,2CAIyB;AAEzB,MAAM,QAAQ,GAAG,eAAS,EACxB,QAAQ,GAAG,mBAAS,CAAA;AACtB,MAAM,EAAE,GAAG,yBAAyB,CAAA;AASpC,MAAM,QAAQ,GAAG,MAAM,CAAA;AAEvB,SAAgB,MAAM,CAAI,CAAI;IAC5B,OAAO,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAA;AAClC,CAAC;AAED,SAAgB,YAAY,CAAI,CAAI;IAClC,OAAO,QAAQ,CAAW,CAAC,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAA;AAC5C,CAAC;AAQD,MAAM,WAAW,GAAG,SAAS,CAAA;AAE7B,SAAgB,SAAS,CAAI,CAAI;IAC/B,OAAO,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,WAAW,CAAC,CAAA;AACrC,CAAC;AAED,SAAgB,eAAe,CAAI,CAAI;IACrC,OAAO,QAAQ,CAAc,CAAC,EAAE,EAAE,EAAE,WAAW,CAAC,CAAA;AAClD,CAAC;AAQD,MAAM,QAAQ,GAAG,MAAM,CAAA;AAEvB,SAAgB,MAAM,CAAI,CAAI;IAC5B,OAAO,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAA;AAClC,CAAC;AAED,SAAgB,YAAY,CAAI,CAAI;IAClC,OAAO,QAAQ,CAAW,CAAC,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAA;AAC5C,CAAC;AAQD,MAAM,OAAO,GAAG,KAAK,CAAA;AAErB,SAAgB,KAAK,CAAI,CAAI;IAC3B,OAAO,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,OAAO,CAAC,CAAA;AACjC,CAAC;AAED,SAAgB,WAAW,CAAI,CAAI;IACjC,OAAO,QAAQ,CAAU,CAAC,EAAE,EAAE,EAAE,OAAO,CAAC,CAAA;AAC1C,CAAC;AASD,MAAM,aAAa,GAAG,WAAW,CAAA;AAEjC,SAAgB,WAAW,CAAI,CAAI;IACjC,OAAO,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,aAAa,CAAC,CAAA;AACvC,CAAC;AAED,SAAgB,iBAAiB,CAAI,CAAI;IACvC,OAAO,QAAQ,CAAgB,CAAC,EAAE,EAAE,EAAE,aAAa,CAAC,CAAA;AACtD,CAAC","sourcesContent":["/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.bsky.richtext.facet'\n\n/** Annotation of a sub-string within rich text. */\nexport interface Main {\n  $type?: 'app.bsky.richtext.facet'\n  index: ByteSlice\n  features: ($Typed<Mention> | $Typed<Link> | $Typed<Tag> | { $type: string })[]\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain)\n}\n\n/** Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID. */\nexport interface Mention {\n  $type?: 'app.bsky.richtext.facet#mention'\n  did: string\n}\n\nconst hashMention = 'mention'\n\nexport function isMention<V>(v: V) {\n  return is$typed(v, id, hashMention)\n}\n\nexport function validateMention<V>(v: V) {\n  return validate<Mention & V>(v, id, hashMention)\n}\n\n/** Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL. */\nexport interface Link {\n  $type?: 'app.bsky.richtext.facet#link'\n  uri: string\n}\n\nconst hashLink = 'link'\n\nexport function isLink<V>(v: V) {\n  return is$typed(v, id, hashLink)\n}\n\nexport function validateLink<V>(v: V) {\n  return validate<Link & V>(v, id, hashLink)\n}\n\n/** Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags'). */\nexport interface Tag {\n  $type?: 'app.bsky.richtext.facet#tag'\n  tag: string\n}\n\nconst hashTag = 'tag'\n\nexport function isTag<V>(v: V) {\n  return is$typed(v, id, hashTag)\n}\n\nexport function validateTag<V>(v: V) {\n  return validate<Tag & V>(v, id, hashTag)\n}\n\n/** Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets. */\nexport interface ByteSlice {\n  $type?: 'app.bsky.richtext.facet#byteSlice'\n  byteStart: number\n  byteEnd: number\n}\n\nconst hashByteSlice = 'byteSlice'\n\nexport function isByteSlice<V>(v: V) {\n  return is$typed(v, id, hashByteSlice)\n}\n\nexport function validateByteSlice<V>(v: V) {\n  return validate<ByteSlice & V>(v, id, hashByteSlice)\n}\n"]}