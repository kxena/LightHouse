{"version":3,"file":"atp-agent.js","sourceRoot":"","sources":["../src/atp-agent.ts"],"names":[],"mappings":"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","sourcesContent":["import { getPdsEndpoint, isValidDidDoc } from '@atproto/common-web'\nimport {\n  ErrorResponseBody,\n  Gettable,\n  ResponseType,\n  XRPCError,\n  XrpcClient,\n  errorResponseBody,\n} from '@atproto/xrpc'\nimport { Agent } from './agent'\nimport {\n  ComAtprotoServerCreateAccount,\n  ComAtprotoServerCreateSession,\n  ComAtprotoServerGetSession,\n  ComAtprotoServerNS,\n} from './client'\nimport { schemas } from './client/lexicons'\nimport { SessionManager } from './session-manager'\nimport {\n  AtpAgentLoginOpts,\n  AtpPersistSessionHandler,\n  AtpSessionData,\n} from './types'\n\nconst ReadableStream = globalThis.ReadableStream as\n  | typeof globalThis.ReadableStream\n  | undefined\n\nexport type AtpAgentOptions = {\n  service: string | URL\n  persistSession?: AtpPersistSessionHandler\n  fetch?: typeof globalThis.fetch\n  headers?: Iterable<[string, Gettable<null | string>]>\n}\n\n/**\n * A wrapper around the {@link Agent} class that uses credential based session\n * management. This class also exposes most of the session management methods\n * directly.\n *\n * This class will be deprecated in the near future. Use {@link Agent} directly\n * with a {@link CredentialSession} instead:\n *\n *  ```ts\n *  const session = new CredentialSession({\n *    service: new URL('https://example.com'),\n *  })\n *\n *  const agent = new Agent(session)\n *  ```\n */\nexport class AtpAgent extends Agent {\n  readonly sessionManager: CredentialSession\n\n  constructor(options: AtpAgentOptions | CredentialSession) {\n    const sessionManager =\n      options instanceof CredentialSession\n        ? options\n        : new CredentialSession(\n            new URL(options.service),\n            options.fetch,\n            options.persistSession,\n          )\n\n    super(sessionManager)\n\n    // This assignment is already being done in the super constructor, but we\n    // need to do it here to make TypeScript happy.\n    this.sessionManager = sessionManager\n\n    if (!(options instanceof CredentialSession) && options.headers) {\n      for (const [key, value] of options.headers) {\n        this.setHeader(key, value)\n      }\n    }\n  }\n\n  clone(): AtpAgent {\n    return this.copyInto(new AtpAgent(this.sessionManager))\n  }\n\n  get session() {\n    return this.sessionManager.session\n  }\n\n  get hasSession() {\n    return this.sessionManager.hasSession\n  }\n\n  get did() {\n    return this.sessionManager.did\n  }\n\n  get serviceUrl() {\n    return this.sessionManager.serviceUrl\n  }\n\n  get pdsUrl() {\n    return this.sessionManager.pdsUrl\n  }\n\n  get dispatchUrl() {\n    return this.sessionManager.dispatchUrl\n  }\n\n  /** @deprecated use {@link serviceUrl} instead */\n  get service() {\n    return this.serviceUrl\n  }\n\n  get persistSession() {\n    throw new Error(\n      'Cannot set persistSession directly. \"persistSession\" is defined through the constructor and will be invoked automatically when session data changes.',\n    )\n  }\n\n  set persistSession(v: unknown) {\n    throw new Error(\n      'Cannot set persistSession directly. \"persistSession\" must be defined in the constructor and can no longer be changed.',\n    )\n  }\n\n  /** @deprecated use {@link AtpAgent.serviceUrl} instead */\n  getServiceUrl() {\n    return this.serviceUrl\n  }\n\n  async resumeSession(\n    session: AtpSessionData,\n  ): Promise<ComAtprotoServerGetSession.Response> {\n    return this.sessionManager.resumeSession(session)\n  }\n\n  async createAccount(\n    data: ComAtprotoServerCreateAccount.InputSchema,\n    opts?: ComAtprotoServerCreateAccount.CallOptions,\n  ): Promise<ComAtprotoServerCreateAccount.Response> {\n    return this.sessionManager.createAccount(data, opts)\n  }\n\n  async login(\n    opts: AtpAgentLoginOpts,\n  ): Promise<ComAtprotoServerCreateSession.Response> {\n    return this.sessionManager.login(opts)\n  }\n\n  async logout(): Promise<void> {\n    return this.sessionManager.logout()\n  }\n}\n\n/**\n * Credentials (username / password) based session manager. Instances of this\n * class will typically be used as the session manager for an {@link AtpAgent}.\n * They can also be used with an {@link XrpcClient}, if you want to use you\n * own Lexicons.\n */\nexport class CredentialSession implements SessionManager {\n  public pdsUrl?: URL // The PDS URL, driven by the did doc\n  public session?: AtpSessionData\n  public refreshSessionPromise: Promise<void> | undefined\n\n  /**\n   * Private {@link ComAtprotoServerNS} used to perform session management API\n   * calls on the service endpoint. Calls performed by this agent will not be\n   * authenticated using the user's session to allow proper manual configuration\n   * of the headers when performing session management operations.\n   */\n  protected server = new ComAtprotoServerNS(\n    // Note that the use of the codegen \"schemas\" (to instantiate `this.api`),\n    // as well as the use of `ComAtprotoServerNS` will cause this class to\n    // reference (way) more code than it actually needs. It is not possible,\n    // with the current state of the codegen, to generate a client that only\n    // includes the methods that are actually used by this class. This is a\n    // known limitation that should be addressed in a future version of the\n    // codegen.\n    new XrpcClient((url, init) => {\n      return (0, this.fetch)(new URL(url, this.serviceUrl), init)\n    }, schemas),\n  )\n\n  constructor(\n    public readonly serviceUrl: URL,\n    public fetch = globalThis.fetch,\n    protected readonly persistSession?: AtpPersistSessionHandler,\n  ) {}\n\n  get did() {\n    return this.session?.did\n  }\n\n  get dispatchUrl() {\n    return this.pdsUrl || this.serviceUrl\n  }\n\n  get hasSession() {\n    return !!this.session\n  }\n\n  /**\n   * Sets a WhatWG \"fetch()\" function to be used for making HTTP requests.\n   */\n  setFetch(fetch = globalThis.fetch) {\n    this.fetch = fetch\n  }\n\n  async fetchHandler(url: string, init?: RequestInit): Promise<Response> {\n    // wait for any active session-refreshes to finish\n    await this.refreshSessionPromise\n\n    const initialUri = new URL(url, this.dispatchUrl)\n    const initialReq = new Request(initialUri, init)\n\n    const initialToken = this.session?.accessJwt\n    if (!initialToken || initialReq.headers.has('authorization')) {\n      return (0, this.fetch)(initialReq)\n    }\n\n    initialReq.headers.set('authorization', `Bearer ${initialToken}`)\n    const initialRes = await (0, this.fetch)(initialReq)\n\n    if (!this.session?.refreshJwt) {\n      return initialRes\n    }\n    const isExpiredToken = await isErrorResponse(\n      initialRes,\n      [400],\n      ['ExpiredToken'],\n    )\n\n    if (!isExpiredToken) {\n      return initialRes\n    }\n\n    try {\n      await this.refreshSession()\n    } catch {\n      return initialRes\n    }\n\n    if (init?.signal?.aborted) {\n      return initialRes\n    }\n\n    // The stream was already consumed. We cannot retry the request. A solution\n    // would be to tee() the input stream but that would bufferize the entire\n    // stream in memory which can lead to memory starvation. Instead, we will\n    // return the original response and let the calling code handle retries.\n    if (ReadableStream && init?.body instanceof ReadableStream) {\n      return initialRes\n    }\n\n    // Return initial \"ExpiredToken\" response if the session was not refreshed.\n    const updatedToken = this.session?.accessJwt\n    if (!updatedToken || updatedToken === initialToken) {\n      return initialRes\n    }\n\n    // Make sure the initial request is cancelled to avoid leaking resources\n    // (NodeJS 👀): https://undici.nodejs.org/#/?id=garbage-collection\n    await initialRes.body?.cancel()\n\n    // We need to re-compute the URI in case the PDS endpoint has changed\n    const updatedUri = new URL(url, this.dispatchUrl)\n    const updatedReq = new Request(updatedUri, init)\n\n    updatedReq.headers.set('authorization', `Bearer ${updatedToken}`)\n\n    return await (0, this.fetch)(updatedReq)\n  }\n\n  /**\n   * Create a new account and hydrate its session in this agent.\n   */\n  async createAccount(\n    data: ComAtprotoServerCreateAccount.InputSchema,\n    opts?: ComAtprotoServerCreateAccount.CallOptions,\n  ): Promise<ComAtprotoServerCreateAccount.Response> {\n    try {\n      const res = await this.server.createAccount(data, opts)\n      this.session = {\n        accessJwt: res.data.accessJwt,\n        refreshJwt: res.data.refreshJwt,\n        handle: res.data.handle,\n        did: res.data.did,\n        email: data.email,\n        emailConfirmed: false,\n        emailAuthFactor: false,\n        active: true,\n      }\n      this.persistSession?.('create', this.session)\n      this._updateApiEndpoint(res.data.didDoc)\n      return res\n    } catch (e) {\n      this.session = undefined\n      this.persistSession?.('create-failed', undefined)\n      throw e\n    }\n  }\n\n  /**\n   * Start a new session with this agent.\n   */\n  async login(\n    opts: AtpAgentLoginOpts,\n  ): Promise<ComAtprotoServerCreateSession.Response> {\n    try {\n      const res = await this.server.createSession({\n        identifier: opts.identifier,\n        password: opts.password,\n        authFactorToken: opts.authFactorToken,\n        allowTakendown: opts.allowTakendown,\n      })\n      this.session = {\n        accessJwt: res.data.accessJwt,\n        refreshJwt: res.data.refreshJwt,\n        handle: res.data.handle,\n        did: res.data.did,\n        email: res.data.email,\n        emailConfirmed: res.data.emailConfirmed,\n        emailAuthFactor: res.data.emailAuthFactor,\n        active: res.data.active ?? true,\n        status: res.data.status,\n      }\n      this._updateApiEndpoint(res.data.didDoc)\n      this.persistSession?.('create', this.session)\n      return res\n    } catch (e) {\n      this.session = undefined\n      this.persistSession?.('create-failed', undefined)\n      throw e\n    }\n  }\n\n  async logout(): Promise<void> {\n    if (this.session) {\n      try {\n        await this.server.deleteSession(undefined, {\n          headers: {\n            authorization: `Bearer ${this.session.refreshJwt}`,\n          },\n        })\n      } catch {\n        // Ignore errors\n      } finally {\n        this.session = undefined\n        this.persistSession?.('expired', undefined)\n      }\n    }\n  }\n\n  /**\n   * Resume a pre-existing session with this agent.\n   */\n  async resumeSession(\n    session: AtpSessionData,\n  ): Promise<ComAtprotoServerGetSession.Response> {\n    this.session = session\n\n    try {\n      const res = await this.server\n        .getSession(undefined, {\n          headers: { authorization: `Bearer ${session.accessJwt}` },\n        })\n        .catch(async (err) => {\n          if (\n            err instanceof XRPCError &&\n            ['ExpiredToken', 'InvalidToken'].includes(err.error) &&\n            session.refreshJwt\n          ) {\n            try {\n              const res = await this.server.refreshSession(undefined, {\n                headers: { authorization: `Bearer ${session.refreshJwt}` },\n              })\n\n              session.accessJwt = res.data.accessJwt\n              session.refreshJwt = res.data.refreshJwt\n\n              return this.server.getSession(undefined, {\n                headers: { authorization: `Bearer ${session.accessJwt}` },\n              })\n            } catch {\n              // Noop, we'll throw the original error\n            }\n          }\n          throw err\n        })\n\n      if (res.data.did !== session.did) {\n        throw new XRPCError(\n          ResponseType.InvalidRequest,\n          'Invalid session',\n          'InvalidDID',\n        )\n      }\n\n      session.email = res.data.email\n      session.handle = res.data.handle\n      session.emailConfirmed = res.data.emailConfirmed\n      session.emailAuthFactor = res.data.emailAuthFactor\n      session.active = res.data.active ?? true\n      session.status = res.data.status\n\n      // protect against concurrent session updates\n      if (this.session === session) {\n        this._updateApiEndpoint(res.data.didDoc)\n        this.persistSession?.('update', session)\n      }\n\n      return res\n    } catch (err) {\n      // protect against concurrent session updates\n      if (this.session === session) {\n        if (\n          err instanceof XRPCError &&\n          ['ExpiredToken', 'InvalidToken'].includes(err.error)\n        ) {\n          this.session = undefined\n          this.persistSession?.('expired', undefined)\n        } else {\n          // Assume the problem is transient and the session can be reused later.\n          this.session = session\n          this.persistSession?.('network-error', session)\n        }\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Internal helper to refresh sessions\n   * - Wraps the actual implementation in a promise-guard to ensure only\n   *   one refresh is attempted at a time.\n   */\n  async refreshSession(): Promise<void> {\n    return (this.refreshSessionPromise ||= this._refreshSessionInner().finally(\n      () => {\n        this.refreshSessionPromise = undefined\n      },\n    ))\n  }\n\n  /**\n   * Internal helper to refresh sessions (actual behavior)\n   */\n  private async _refreshSessionInner() {\n    if (!this.session?.refreshJwt) {\n      return\n    }\n\n    try {\n      const res = await this.server.refreshSession(undefined, {\n        headers: { authorization: `Bearer ${this.session.refreshJwt}` },\n      })\n      // succeeded, update the session\n      this.session = {\n        ...this.session,\n        accessJwt: res.data.accessJwt,\n        refreshJwt: res.data.refreshJwt,\n        handle: res.data.handle,\n        did: res.data.did,\n      }\n      this._updateApiEndpoint(res.data.didDoc)\n      this.persistSession?.('update', this.session)\n    } catch (err) {\n      if (\n        err instanceof XRPCError &&\n        err.error &&\n        ['ExpiredToken', 'InvalidToken'].includes(err.error)\n      ) {\n        // failed due to a bad refresh token\n        this.session = undefined\n        this.persistSession?.('expired', undefined)\n      }\n      // else: other failures should be ignored - the issue will\n      // propagate in the _dispatch() second attempt to run\n      // the request\n    }\n  }\n\n  /**\n   * Helper to update the pds endpoint dynamically.\n   *\n   * The session methods (create, resume, refresh) may respond with the user's\n   * did document which contains the user's canonical PDS endpoint. That endpoint\n   * may differ from the endpoint used to contact the server. We capture that\n   * PDS endpoint and update the client to use that given endpoint for future\n   * requests. (This helps ensure smooth migrations between PDSes, especially\n   * when the PDSes are operated by a single org.)\n   */\n  private _updateApiEndpoint(didDoc: unknown) {\n    if (isValidDidDoc(didDoc)) {\n      const endpoint = getPdsEndpoint(didDoc)\n      this.pdsUrl = endpoint ? new URL(endpoint) : undefined\n    } else {\n      // If the did doc is invalid, we clear the pdsUrl (should never happen)\n      this.pdsUrl = undefined\n    }\n  }\n}\n\nfunction isErrorObject(v: unknown): v is ErrorResponseBody {\n  return errorResponseBody.safeParse(v).success\n}\n\nasync function isErrorResponse(\n  response: Response,\n  status: number[],\n  errorNames: string[],\n): Promise<boolean> {\n  if (!status.includes(response.status)) return false\n  // Some engines (react-native 👀) don't expose a response.body property...\n  // if (!response.body) return false\n  try {\n    const json = await peekJson(response, 10 * 1024)\n    return isErrorObject(json) && (errorNames as any[]).includes(json.error)\n  } catch (err) {\n    return false\n  }\n}\n\nasync function peekJson(\n  response: Response,\n  maxSize = Infinity,\n): Promise<unknown> {\n  if (extractType(response) !== 'application/json') throw new Error('Not JSON')\n  if (extractLength(response) > maxSize) throw new Error('Response too large')\n  return response.clone().json()\n}\n\nfunction extractLength({ headers }: Response) {\n  return headers.get('Content-Length')\n    ? Number(headers.get('Content-Length'))\n    : NaN\n}\n\nfunction extractType({ headers }: Response) {\n  return headers.get('Content-Type')?.split(';')[0]?.trim()\n}\n"]}