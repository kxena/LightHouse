{"version":3,"file":"util.js","sourceRoot":"","sources":["../../src/client/util.ts"],"names":[],"mappings":";AAAA;;GAEG;;AAgDH,4BAMC;AAED,kCASC;AAUD,kCAIC;AAhED,SAAS,QAAQ,CAAI,CAAI;IACvB,OAAO,CAAC,IAAI,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,CAAA;AAC3C,CAAC;AAED,SAAS,OAAO,CACd,KAAc,EACd,EAAM,EACN,IAAU;IAEV,OAAO,IAAI,KAAK,MAAM;QACpB,CAAC,CAAC,KAAK,KAAK,EAAE;QACd,CAAC,CAAC,4BAA4B;YAC5B,OAAO,KAAK,KAAK,QAAQ;gBACvB,KAAK,CAAC,MAAM,KAAK,EAAE,CAAC,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM;gBAC5C,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,SAAS;gBAC5C,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC;gBACpB,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;AAC5B,CAAC;AAgBD,SAAgB,QAAQ,CACtB,CAAI,EACJ,EAAM,EACN,IAAU;IAEV,OAAO,QAAQ,CAAC,CAAC,CAAC,IAAI,OAAO,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,EAAE,IAAI,CAAC,CAAA;AAClE,CAAC;AAED,SAAgB,WAAW,CACzB,CAAI,EACJ,EAAM,EACN,IAAU;IAEV,OAAO,CACL,QAAQ,CAAC,CAAC,CAAC;QACX,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,SAAS,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAC5E,CAAA;AACH,CAAC;AAMD;;;GAGG;AACH,SAAgB,WAAW,CAAsB,QAAW;IAC1D,OAAO,UAAa,CAAI;QACtB,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAA;IAC5B,CAAC,CAAA;AACH,CAAC","sourcesContent":["/**\n * GENERATED CODE - DO NOT MODIFY\n */\n\nimport { type ValidationResult } from '@atproto/lexicon'\n\nexport type OmitKey<T, K extends keyof T> = {\n  [K2 in keyof T as K2 extends K ? never : K2]: T[K2]\n}\n\nexport type $Typed<V, T extends string = string> = V & { $type: T }\nexport type Un$Typed<V extends { $type?: string }> = OmitKey<V, '$type'>\n\nexport type $Type<Id extends string, Hash extends string> = Hash extends 'main'\n  ? Id\n  : `${Id}#${Hash}`\n\nfunction isObject<V>(v: V): v is V & object {\n  return v != null && typeof v === 'object'\n}\n\nfunction is$type<Id extends string, Hash extends string>(\n  $type: unknown,\n  id: Id,\n  hash: Hash,\n): $type is $Type<Id, Hash> {\n  return hash === 'main'\n    ? $type === id\n    : // $type === `${id}#${hash}`\n      typeof $type === 'string' &&\n        $type.length === id.length + 1 + hash.length &&\n        $type.charCodeAt(id.length) === 35 /* '#' */ &&\n        $type.startsWith(id) &&\n        $type.endsWith(hash)\n}\n\nexport type $TypedObject<\n  V,\n  Id extends string,\n  Hash extends string,\n> = V extends {\n  $type: $Type<Id, Hash>\n}\n  ? V\n  : V extends { $type?: string }\n    ? V extends { $type?: infer T extends $Type<Id, Hash> }\n      ? V & { $type: T }\n      : never\n    : V & { $type: $Type<Id, Hash> }\n\nexport function is$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is $TypedObject<V, Id, Hash> {\n  return isObject(v) && '$type' in v && is$type(v.$type, id, hash)\n}\n\nexport function maybe$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is V & object & { $type?: $Type<Id, Hash> } {\n  return (\n    isObject(v) &&\n    ('$type' in v ? v.$type === undefined || is$type(v.$type, id, hash) : true)\n  )\n}\n\nexport type Validator<R = unknown> = (v: unknown) => ValidationResult<R>\nexport type ValidatorParam<V extends Validator> =\n  V extends Validator<infer R> ? R : never\n\n/**\n * Utility function that allows to convert a \"validate*\" utility function into a\n * type predicate.\n */\nexport function asPredicate<V extends Validator>(validate: V) {\n  return function <T>(v: T): v is T & ValidatorParam<V> {\n    return validate(v).success\n  }\n}\n"]}