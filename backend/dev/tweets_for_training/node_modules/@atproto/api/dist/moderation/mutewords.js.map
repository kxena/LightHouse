{"version":3,"file":"mutewords.js","sourceRoot":"","sources":["../../src/moderation/mutewords.ts"],"names":[],"mappings":";;AA+CA,wCAkHC;AAMD,oCAEC;AAzKD,sCAAkE;AAElE,MAAM,KAAK,GAAG;IACZ,4BAA4B,EAAE,uBAAuB;IACrD,MAAM,EAAE,uBAAuB;IAC/B,UAAU,EAAE,iBAAiB;IAC7B,aAAa,EAAE,mBAAmB;CACnC,CAAA;AAED;;;;;GAKG;AACH,MAAM,mBAAmB,GAAG;IAC1B,IAAI,EAAE,WAAW;IACjB,IAAI,EAAE,UAAU;IAChB,IAAI,EAAE,SAAS;IACf,IAAI,EAAE,OAAO;IACb,IAAI,EAAE,aAAa;CACpB,CAAA;AAsBD;;;GAGG;AACH,SAAgB,cAAc,CAAC,EAC7B,UAAU,EACV,IAAI,EACJ,MAAM,EACN,WAAW,EACX,SAAS,EACT,KAAK,GACE;IACP,MAAM,SAAS,GAAG,mBAAmB,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAA;IACpE,MAAM,IAAI,GAAI,EAAe;SAC1B,MAAM,CAAC,WAAW,IAAI,EAAE,CAAC;SACzB,MAAM,CACL,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAC/B,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,6BAAoB,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CACxE,CACF;SACA,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAA;IAE9B,MAAM,OAAO,GAAoB,EAAE,CAAA;IAEnC,KAAK,EAAE,KAAK,MAAM,QAAQ,IAAI,UAAU,EAAE,CAAC;QACzC,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,CAAA;QAC9C,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,EAAE,CAAA;QAEnC,kBAAkB;QAClB,IAAI,QAAQ,CAAC,SAAS,IAAI,QAAQ,CAAC,SAAS,GAAG,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;YACrE,SAAQ;QAEV,IACE,QAAQ,CAAC,WAAW,KAAK,mBAAmB;YAC5C,OAAO,CAAC,KAAK,EAAE,MAAM,EAAE,SAAS,CAAC;YAEjC,SAAQ;QAEV,oCAAoC;QACpC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC;YAC7B,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAA;YAC3D,SAAQ;QACV,CAAC;QACD,4CAA4C;QAC5C,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC;YAAE,SAAQ;QACnD,2DAA2D;QAC3D,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,SAAS,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC;YAC1E,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAA;YAC3D,SAAQ;QACV,CAAC;QACD,WAAW;QACX,IAAI,SAAS,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM;YAAE,SAAQ;QAChD,cAAc;QACd,IAAI,SAAS,KAAK,QAAQ,EAAE,CAAC;YAC3B,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAA;YAC3D,SAAQ;QACV,CAAC;QACD,6CAA6C;QAC7C,IAAI,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC;YACtE,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAA;YAC3D,SAAQ;QACV,CAAC;QAED,oCAAoC;QACpC,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,CAAA;QACjD,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACzB,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;gBACvB,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAA;gBACjD,SAAS,KAAK,CAAA;YAChB,CAAC;YAED,wEAAwE;YACxE,gCAAgC;YAChC,MAAM,sBAAsB,GAAG,IAAI,CAAC,OAAO,CACzC,KAAK,CAAC,4BAA4B,EAClC,EAAE,CACH,CAAA;YAED,IAAI,SAAS,KAAK,sBAAsB,EAAE,CAAC;gBACzC,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAA;gBACjD,SAAS,KAAK,CAAA;YAChB,CAAC;YAED,IAAI,SAAS,CAAC,MAAM,GAAG,sBAAsB,CAAC,MAAM;gBAAE,SAAQ;YAE9D,IAAI,SAAS,CAAC,IAAI,CAAC,sBAAsB,CAAC,EAAE,CAAC;gBAC3C;;;mBAGG;gBACH,IAAI,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,EAAE,CAAC;oBACxC,SAAS,KAAK,CAAA;gBAChB,CAAC;gBAED,MAAM,UAAU,GAAG,sBAAsB,CAAC,OAAO,CAAC,UAAU,EAAE,GAAG,CAAC,CAAA;gBAClE,IAAI,UAAU,KAAK,SAAS,EAAE,CAAC;oBAC7B,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAA;oBACjD,SAAS,KAAK,CAAA;gBAChB,CAAC;gBAED,MAAM,cAAc,GAAG,UAAU,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAA;gBACrD,IAAI,cAAc,KAAK,SAAS,EAAE,CAAC;oBACjC,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAA;oBACjD,SAAS,KAAK,CAAA;gBAChB,CAAC;gBAED,MAAM,SAAS,GAAG,sBAAsB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA;gBACzD,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE,CAAC;oBACjC,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;wBAC3B,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAA;wBACjD,SAAS,KAAK,CAAA;oBAChB,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS,CAAA;AAC7C,CAAC;AAED;;;GAGG;AACH,SAAgB,YAAY,CAAC,MAAc;IACzC,OAAO,CAAC,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;AACjC,CAAC","sourcesContent":["import { AppBskyActorDefs, AppBskyRichtextFacet } from '../client'\n\nconst REGEX = {\n  LEADING_TRAILING_PUNCTUATION: /(?:^\\p{P}+|\\p{P}+$)/gu,\n  ESCAPE: /[[\\]{}()*+?.\\\\^$|\\s]/g,\n  SEPARATORS: /[/\\-–—()[\\]_]+/g,\n  WORD_BOUNDARY: /[\\s\\n\\t\\r\\f\\v]+?/g,\n}\n\n/**\n * List of 2-letter lang codes for languages that either don't use spaces, or\n * don't use spaces in a way conducive to word-based filtering.\n *\n * For these, we use a simple `String.includes` to check for a match.\n */\nconst LANGUAGE_EXCEPTIONS = [\n  'ja', // Japanese\n  'zh', // Chinese\n  'ko', // Korean\n  'th', // Thai\n  'vi', // Vietnamese\n]\n\nexport type MuteWordMatch = {\n  /**\n   * The `AppBskyActorDefs.MutedWord` that matched.\n   */\n  word: AppBskyActorDefs.MutedWord\n  /**\n   * The string that matched the muted word.\n   */\n  predicate: string\n}\n\nexport type Params = {\n  mutedWords: AppBskyActorDefs.MutedWord[]\n  text: string\n  facets?: AppBskyRichtextFacet.Main[]\n  outlineTags?: string[]\n  languages?: string[]\n  actor?: AppBskyActorDefs.ProfileView | AppBskyActorDefs.ProfileViewBasic\n}\n\n/**\n * Checks if the given text matches any of the muted words, returning an array\n * of matches. If no matches are found, returns `undefined`.\n */\nexport function matchMuteWords({\n  mutedWords,\n  text,\n  facets,\n  outlineTags,\n  languages,\n  actor,\n}: Params): MuteWordMatch[] | undefined {\n  const exception = LANGUAGE_EXCEPTIONS.includes(languages?.[0] || '')\n  const tags = ([] as string[])\n    .concat(outlineTags || [])\n    .concat(\n      (facets || []).flatMap((facet) =>\n        facet.features.filter(AppBskyRichtextFacet.isTag).map((tag) => tag.tag),\n      ),\n    )\n    .map((t) => t.toLowerCase())\n\n  const matches: MuteWordMatch[] = []\n\n  outer: for (const muteWord of mutedWords) {\n    const mutedWord = muteWord.value.toLowerCase()\n    const postText = text.toLowerCase()\n\n    // expired, ignore\n    if (muteWord.expiresAt && muteWord.expiresAt < new Date().toISOString())\n      continue\n\n    if (\n      muteWord.actorTarget === 'exclude-following' &&\n      Boolean(actor?.viewer?.following)\n    )\n      continue\n\n    // `content` applies to tags as well\n    if (tags.includes(mutedWord)) {\n      matches.push({ word: muteWord, predicate: muteWord.value })\n      continue\n    }\n    // rest of the checks are for `content` only\n    if (!muteWord.targets.includes('content')) continue\n    // single character or other exception, has to use includes\n    if ((mutedWord.length === 1 || exception) && postText.includes(mutedWord)) {\n      matches.push({ word: muteWord, predicate: muteWord.value })\n      continue\n    }\n    // too long\n    if (mutedWord.length > postText.length) continue\n    // exact match\n    if (mutedWord === postText) {\n      matches.push({ word: muteWord, predicate: muteWord.value })\n      continue\n    }\n    // any muted phrase with space or punctuation\n    if (/(?:\\s|\\p{P})+?/u.test(mutedWord) && postText.includes(mutedWord)) {\n      matches.push({ word: muteWord, predicate: muteWord.value })\n      continue\n    }\n\n    // check individual character groups\n    const words = postText.split(REGEX.WORD_BOUNDARY)\n    for (const word of words) {\n      if (word === mutedWord) {\n        matches.push({ word: muteWord, predicate: word })\n        continue outer\n      }\n\n      // compare word without leading/trailing punctuation, but allow internal\n      // punctuation (such as `s@ssy`)\n      const wordTrimmedPunctuation = word.replace(\n        REGEX.LEADING_TRAILING_PUNCTUATION,\n        '',\n      )\n\n      if (mutedWord === wordTrimmedPunctuation) {\n        matches.push({ word: muteWord, predicate: word })\n        continue outer\n      }\n\n      if (mutedWord.length > wordTrimmedPunctuation.length) continue\n\n      if (/\\p{P}+/u.test(wordTrimmedPunctuation)) {\n        /**\n         * Exit case for any punctuation within the predicate that we _do_\n         * allow e.g. `and/or` should not match `Andor`.\n         */\n        if (/[/]+/.test(wordTrimmedPunctuation)) {\n          continue outer\n        }\n\n        const spacedWord = wordTrimmedPunctuation.replace(/\\p{P}+/gu, ' ')\n        if (spacedWord === mutedWord) {\n          matches.push({ word: muteWord, predicate: word })\n          continue outer\n        }\n\n        const contiguousWord = spacedWord.replace(/\\s/gu, '')\n        if (contiguousWord === mutedWord) {\n          matches.push({ word: muteWord, predicate: word })\n          continue outer\n        }\n\n        const wordParts = wordTrimmedPunctuation.split(/\\p{P}+/u)\n        for (const wordPart of wordParts) {\n          if (wordPart === mutedWord) {\n            matches.push({ word: muteWord, predicate: word })\n            continue outer\n          }\n        }\n      }\n    }\n  }\n\n  return matches.length ? matches : undefined\n}\n\n/**\n * Checks if the given text matches any of the muted words, returning a boolean\n * if any matches are found.\n */\nexport function hasMutedWord(params: Params) {\n  return !!matchMuteWords(params)\n}\n"]}